# 다형성
## 다형성의 정의 및 사용 이유
- 다형성(Polymorphism)
    * 하나의 인스턴스가 여러가지 타입을 가질 수 있는 것을 의미
    * 객체지향 프로그래밍의 3대 특징(캡슐화, 상속, 다형성) 중 하나임

- 다형성의 장점
    * 여러 타입의 객체를 하나의 타입으로 관리 가능함
    * 상속관계에 있는 모든 객체는 동일한 메세지를 수신할 수 있음
    * 동일한 메세지를 수신받아 처리하는 내용을 객체별로 다르게 할 수 있음
    * 확장성이 좋은 코드를 작성할 수 있음
    * 결합도를 낮춰 유지보수성을 증가시킴

- 동적 바인딩
    * 컴파일 당시에는 해당 타입의 메소드와 연결되어 있다가 런타임 시 실제 해당 인스턴스가 메소드(오버라이딩 한 메소드)로 바인딩이 바뀌어 동작하는 것을 의미
    * 동적 바인딩은 상속 관계를 가지는 부모 자식 클래스에 오버라이딩 된 메소드를 호출해야 함
    ```java
    Parent p = new Child();
    p.methodA();
    ```

- 업캐스팅과 다운캐스팅
> 상속관계에 있지만 오버라이딩 한 것이 아닌 후손 객체가 고유하게 가지는 확장된 기능을 사용하기 위해서는 실제 인스턴스의 타입으로 다운캐스팅(클래스 형변환)을 해주어야 한다.<br> 클래스 형변환은 상위 타입 형변환(up-casting)과 하위 타입 형변환(down-casting)이 있다. 상위 타입 형변환의 경우 묵시적으로 일어나며, 하위 타입 형변환은 명시적으로 작성해야 한다.

- instanceof 연산자
    * 레퍼련스 변수가 실제로 어떤 클래스 타입의 인스턴스인지 확인하여 true or false를 반환
    * 클래스 형변환의 경우 런타임시 존재하는 타입과 형변환하려는 타입이 일치하지 않는 경우 ClassCastException 발생
    * 런타임 시 안전한 형변환을 하기 위해 instanceof 연산자를 사용
    ```java
    /* 표현식 */
    if(레퍼런스 변수 instanceof 클래스 타입) {
        // true일 때 처리할 내용, 해당 클래스 타입으로 down-casting할 것
    }
    
    /* 예시 */
    Car car = new Sonata();
    if (car instanceof Sonata) {
        ((Sonata) car).moveSonata();
    } else if (car instanceof Avante) {
        ((Avante) car).moveAvante();
    } else if (car instanceof Grandure) {
        ((Grandure) car).moveGrandure();
    }
    ```

## 추상클래스
- 추상클래스(Abstract Class)
    * 추상 메소드(메소드의 기능이 없고 메소드의 헤더부만 존재하는 불완전한 메소드)를 0개 이상 포함하는 클래스
    * 추상 클래스는 상속을 활용해 하위 클래스 타입의 인스턴스롤 이용해서 인스턴스를 생성해야 함
    * 스스로 자신의 생성자를 활용한 인스턴스 생성이 불가능함
    ```java
    /* 추상클래스 */
    // 추상메소드를 하나라도 포함하면 반드시 추상클래스(불완전한 클래스)가 됨
    class abstract AbstractClass() {

        // 메소드의 바디가 없는 추상메소드
        // 메소드의 헤더(접근제어자, 예약어, 반환형, 메소드명 매개변수)만 존재
        public abstract void method();  // 추상메소드는 반드시 끝에 ;을 붙여야 함

        public void method2(){}    // 완전한 메소드가 있어도 됨
    }
    ```

- 추상클래스 사용 이유
    * 추상클래스는 다형성 적용을 위한 부모 타입 역할을 할 수 있음
    * 오버라이딩에 대한 강제성을 부여
    * 일관된 인터페이스(동일 기능)를 제공


## 인터페이스
- 인터페이스(Interface)
    * 추상메소드와 상수 필드만 가질 수 있는 클래스의 변형체
    * **implements** 키워드를 사용하여 자식클래스 입장에서 '**구현한다**'라는 표현을 씀
    ```java
    interface TestInter {
        // 모든 필드는 public static final만 가능(생략 가능)
        public static final PI = 3.1415;

        // 기본적으로 메소드는 public abstract여야 함(생략 가능)
        public abstract oid method();
    }
    ```

- 인터페이스 사용 이유
    * 공유를 목적으로 하는 상수를 기반으로 모든 기능을 공통화해서 강제성을 부여(공통된 인터페이스)
    * Java의 단일 상속 단점을 극복 -> 여러 개의 인터페이스를 구현할 수 있음

## 추상클래스와 인터페이스의 비교
|구분|`추상클래스`|`인터페이스`|
|---|---|---|
|상속 가능 범위|단일 상속|다중 상속|
|키워드|extends|implements|
|추상메소드 갯수|0개 이상|모든 메소드|
|abstract 키워드 명시|명시적 사용|묵시적으로 abstract|
|자체 인스턴스 생성|생성 불가|생성 불가|
|다형성 적용 시 상위타입 활용 가능 유무|가능|가능|
